<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录学习、工作、生活"><title>Redux 中间件机制探底 | 李茶德的日记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redux 中间件机制探底</h1><a id="logo" href="/.">李茶德的日记</a><p class="description">记录学习、工作、生活</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa null"> 首页</i></a><a href="/archives/"><i class="fa null"> 归档</i></a><a href="/about/"><i class="fa null"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1"><div class="content_container"><div class="post"><h1 class="post-title">Redux 中间件机制探底</h1><div class="post-meta">2019-12-27</div><div class="post-content"><p>状态管理方案之前仅仅接触过 Vuex, 使用 React 开发时，难免要调研一下 React 技术栈下的状态管理方案，发现有 Redux 和 Mobx 相关流派。以下内容仅针对 Redux 展开讨论。</p>
<p>在使用 Redux 的过程中发现，有这么几个知识点还是比较容易接受：</p>
<ol>
<li>对状态的修改必须 dispatch 一个 action, 保证状态的修改可控易管理</li>
<li>reducer 必须是一个纯函数，不能对 state 直接进行修改，而是每次返回一个全新的 state。纯函数的实现可以提高运行效率，固定的输入产生固定的输出</li>
<li>redux 本身有一个「订阅」的概念，状态更改后， Redux 会将依次执行订阅者，在订阅者的事件回调函数中可以通过 <code>store.getState()</code> 拿到最新的状态</li>
</ol>
<a id="more"></a>
<p>此时有这样一个疑问： 上面仅仅讨论了一个同步的情况，对于一些异步以及存在其他副作用的 action 产生过程如何处理，带着这个疑问，看了官方文档以及一些 Demo 实现。这个过程出现了 redux-thunk、redux-promise、 redux-saga 等处理方案。这些又是做什么的，分别都解决了什么问题？</p>
<p>这就要讨论一下 Redux 的中间件机制，在 Redux 中有这样一个 API, <code>applyMiddleware</code>, 主要用于注册 Redux 中的中间件。</p>
<p>阅读文档的过程中，主要搞清楚了一个最基本的世界观问题： <strong>Redux 的中间件是用来做什么的？它提供的是位于 action 被发起之后，到达 reducer 之前的扩展点</strong>。 也就是以上讨论的 redux-thunk、redux-promise、redux-saga 等都是一个个的 Redux 的中间件，使用时需要在 Redux <code>createStore</code> 时注册，他们分别增强了 Redux dispatch 的能力。同样可以理解为：在应用这些中间件后，使用的 dispatch 已经不是 Redux 原本的 dispatch，都是经这些中间件改写后的 dispatch。这样我们就能再真正产生 action 之前做一些副作用的封装。</p>
<p>以 redux-thunk 为例，我们可以清晰的的看清楚这个过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>
<p>以上就是 redux-thunk 这个库的源码部分，「短小精悍」这个词来形容这个库一点都不过分了。究其实现，可以发现，<strong>redux-thunk 这个中间件主要是提供了 dispatch 一个 function 的能力</strong>。正常来说 Redux 的 dispatch 仅仅能 dispatch 一个纯js对象，也就是 action。 使用 redux-thunk 后，我们可以接收一个 function， 这个 function 会被得到调用，并被传入 dispatch 这个参数，真正的 dispatch 发生在这个 function 内部。</p>
<p>至于 Redux 的中间件机制是如何实现的，在看了其源码实现后，更是巧妙。</p>
<p>首先我们要明确一下 「中间件」 这个概念。个人粗俗理解：中间件就是一个「管道」，只要你过了这个「管道」，都会被这个「管道」接管，「管道」不会拦住不放，而是将你「蹂躏」一番再放了你，当然也有可能不「蹂躏」你，顶多查一下户口(传说中的日志中间件)。凡是经「蹂躏」过的不管是从精神上、还是肉体上都不再是原来的你我，可能是一蹶不振，也可能是奋发图强。</p>
<p>有了以上的理解，当我们在看这个事情的时候就好理解了。可能会有多个中间件，只要进了这个「屋」，就要依次经历这些中间件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reduxMiddleware = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 做一些查户口以及蹂躏相关的事情 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 放行</span></span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个 redux middleware 的通用实现。当我们在 <code>applyMiddleware</code> 时发生了什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(&#123;</span><br><span class="line">  getState: store.getState,</span><br><span class="line">  dispatch: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args),</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dispatch = compose(chain)(store.dispatch);</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...store,</span><br><span class="line">  dispatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致意思就是将所有的 middleware 传入，并通过 <code>compose</code> 这个函数将所有的中间件组合并返回一个 <code>dispatch</code> 函数， 此时的 <code>dispatch</code> 不是 redux 原本的 dispatch 实现，而是一个经中间件增强了的 dispatch，这里面有一个控制权的反转，即将原本的 dispatch 功能作为参数传入，在函数内部完成 dispatch 的逻辑。此时的 dispatch 可能是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do things</span></span><br><span class="line">  <span class="comment">// 这里经过了所有注册过的中间件的处理</span></span><br><span class="line">  <span class="comment">// do things</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redux 中间件实现的关键是 <code>compose</code> 函数，<code>compose</code> 函数利用 <code>Array.prototype.reduce()</code> API，完成所有中间件函数的依次调用，并返回如上所示的一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a((b(...args))));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上便是整个中间件机制的实现过程。因为中间涉及到一些函数柯里化的内容，有些函数嵌套较深才能返回，如果感觉到晦涩，可以看这个简洁版的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个中间件</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'经过了 a 中间件的蹂躏'</span>);</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个中间件</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'经过了 b 中间件的蹂躏'</span>);</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个中间件</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'经过了 c 中间件的蹂躏'</span>);;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原版的 dispatch</span></span><br><span class="line"><span class="keyword">var</span> rawDispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'终于轮到原生的dispatch action了，派发了： '</span>, action);</span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以下是 applyMiddlware 的实现原理， 开始注册中间件 */</span></span><br><span class="line"><span class="keyword">var</span> arr = [a, b, c];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> enhanceDispatch = res(rawDispatch);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用一个增强的dispatch，会发现中间件逻辑会一次处理</span></span><br><span class="line">enhanceDispatch(<span class="string">'add'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过了 a 中间件的蹂躏</span></span><br><span class="line"><span class="comment">// 经过了 b 中间件的蹂躏</span></span><br><span class="line"><span class="comment">// 经过了 c 中间件的蹂躏</span></span><br><span class="line"><span class="comment">// 终于轮到原生的 dispatch action了，派发了：  add</span></span><br><span class="line"><span class="comment">// "add"</span></span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ol>
<li><a href="https://www.redux.org.cn/docs/advanced/Middleware.html" target="_blank" rel="noopener">https://www.redux.org.cn/docs/advanced/Middleware.html</a></li>
</ol>
</div><div class="tags"><a href="/tags/redux/">redux</a><a href="/tags/middleware/">middleware</a><a href="/tags/redux-thunk/">redux-thunk</a><a href="/tags/redux-saga/">redux-saga</a></div><div class="post-nav"><a href="/2020/01/01/与青春有关的日子/" class="pre">观《与青春有关的日子》</a><a href="/2019/12/27/redux-and-react-redux/" class="next">状态管理之 Redux &amp; React Redux</a></div></div></div></div><div class="pure-u-1"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">李茶德的日记.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 京ICP备17057625号.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>