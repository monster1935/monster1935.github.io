<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录学习、工作、生活"><title>数据结构中常用的几种排序算法 | 李茶德的日记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构中常用的几种排序算法</h1><a id="logo" href="/.">李茶德的日记</a><p class="description">记录学习、工作、生活</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa null"> 首页</i></a><a href="/archives/"><i class="fa null"> 归档</i></a><a href="/about/"><i class="fa null"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1"><div class="content_container"><div class="post"><h1 class="post-title">数据结构中常用的几种排序算法</h1><div class="post-meta">2016-09-28<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span></div><div class="post-content"><p>“来同学，咱们做个题吧，写个最基本的快排。。。”，校招季的各种面试中相信大家经常听到类似的话语。排序是作为数据结构中比较重要的一部分来讲，今天笔者又拿出来当年的数据结构课本进行了一下总结，并对几个重要的排序算法进行了实现。<br><a id="more"></a></p>
<h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><p><strong>排序：</strong> 重新排列表中的元素，使表中的元素按照关键字递增或者递减的过程。<br><strong>算法的稳定性：</strong> 如果在排序序列中存在多个具有相同关键字的元素，在经过排序后，这些记录的相对次序依然保持不变，则称这种排序算法是稳定的，否则称之为不稳定的。<br><strong>内部排序：</strong> 在排序期间元素全部存放在内存中的排序。<br><strong>外部排序：</strong> 在排序期间无法全部同时存放在内存中，必须在排序过程中根据要求不断地在内、外存之间移动的排序。</p>
<p>下图为排序的逻辑导图：</p>
<p><img src="http://oe7c74ud3.bkt.clouddn.com/sort.png" alt></p>
<h2 id="各种排序算法的比较"><a href="#各种排序算法的比较" class="headerlink" title="各种排序算法的比较"></a>各种排序算法的比较</h2><p>下面进行比较的排序算法主要针对内部排序，外部排序此处暂且不做讨论。一般内部排序算法在执行过程中主要是基于以下两种操作来进行的：比较和移动，通过比较两个关键字的大小，确定元素的前后关系，然后通过移动元素达到有序。此处需要注意的是：<strong>基数排序是不需要进行比较的</strong></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序方法，其思想在于<strong>每次将一个待排序的记录，按其关键字的大小插入到前面已经排序好的子序列中，直到全部记录插入完成。</strong>插入排序又分为：直接插入排序，折半插入排序，希尔排序。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>直接插入排序的思想：为了将arr[i]插入到arr[0…i-1]中,需要依次执行以下操作：</p>
<ul>
<li>查找出arr[i]在arr[0…i-1]中的插入位置k</li>
<li>将arr[k…i-1]中所有元素全部后移一个位置</li>
<li>将arr[i]复制到arr[k]</li>
</ul>
<p>为了实现整个排序过程，只要从数组的第一个元素即arr[1]到arr[n-1]执行n-1次上述操作即可。<br>以下是使用java实现的插入排序过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;<span class="comment">//依次将arr[1]-arr[n-1]插入到前面已排序序列</span></span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			<span class="keyword">for</span>(j=i-<span class="number">1</span>;temp&lt;arr[j];j--)&#123;</span><br><span class="line">				arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	print(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接插入排序算法的性能分析：<br>空间效率：仅仅使用了常数个辅助单元，因此空间复杂度为O(1)<br>时间效率：在排序过程中，向有序的序列中插入元素的操作进行了n-1次，每次操作都分为比较和移动两个操作，比较的次数和移动的次数取决于待排序序列的初始状态。最好情况下，数组整体是有序的，插入元素的过程仅仅需要比较，并不需要移动元素，因此最坏情况下时间复杂度为O(n)。最坏情况下，数组的元素顺序正好和排序结果的元素顺序相反，此时每次插入都需要比较和移动。<strong>平均情况下，考虑待排序数组中的元素是随机的，时间复杂度为O(n^2)。</strong><br>稳定性：由于每次插入元素都是先比较在移动，因此不会出现相同元素相对位置发生变化的情况。<strong>因此直接插入排序算法是稳定的。</strong></p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>折半插入排序在直接插入排序算法的基础做了改进。折半插入排序将整个排序过程分为两个过程：通过折半查找找出待插入的位置，然后统一移动元素。</p>
<p>以下是使用java实现的折半插入排序过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		low = <span class="number">0</span>;</span><br><span class="line">		high = i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">			mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(arr[mid]&gt;temp)&#123;</span><br><span class="line">				high=mid-<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				low=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=high+<span class="number">1</span>;j--)&#123;</span><br><span class="line">			arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[high+<span class="number">1</span>]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	print(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>折半插入排序算法性能分析：<br>折半插入排序算法相对于直接插入排序算法来说仅仅是减少了元素的比较次数，元素的移动次数并没有改变，因此<strong>折半插入的时间复杂度仍为O(n^2),空间复杂度为O(1),折半插入排序算法是稳定的。</strong></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序又叫缩小增量排序，其基本思想是：先将排序表按照一定增量分为若干个待排序的字表，分别进行直接插入排序，当整个表中元素已呈”基本有序”时，再对整体进行一次直接插入排序。</p>
<p>以下是java实现的希尔排序过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> i,j,d,len = arr.length;</span><br><span class="line">   	<span class="keyword">for</span>(d=len/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>)&#123;</span><br><span class="line">   		<span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">   			<span class="keyword">if</span>(arr[i]&lt;arr[i-d])&#123;</span><br><span class="line">   				<span class="keyword">int</span> temp=arr[i];</span><br><span class="line">   				<span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;temp&lt;arr[j];j-=d)&#123;</span><br><span class="line">   					arr[j+d]=arr[j];</span><br><span class="line">   				&#125;</span><br><span class="line">   				arr[j+d]=temp;</span><br><span class="line">   			&#125;</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   	print(arr);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>希尔排序算法的性能分析：<br>空间效率：使用了常数个辅助单元，空间复杂度为O(1)<br>时间效率：最坏情况下希尔排序的时间复杂度为O(n^2)<br>稳定性：希尔排序算法不是一个稳定的排序算法</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>直接插入排序和折半插入排序适用于基本有序的排序表和数据量不大的排序表。因为其中涉及到大量的移动元素，在数据量较小的时候，虽然两者的时间复杂度都为O(n^2)，折半插入排序往往能表现更好的性能。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想在于根据序列中两个元素的比较结果对换这两个元素在序列中的位置。交换排序有很多种实现算法，此处只讨论冒泡排序和快速排序。其中快速排序是重点内容。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是一种比较简单排序算法。其基本思想是：在一个长为n的待排序表中，从后向前（也可以从前向后）两两比较相邻的元素，如果arr[i-1]&gt;arr[i]时，则交换它们，直到序列比较完，这位一次冒泡过程。一次冒泡的结果就是将最小的元素交换到待排序序列的第一个位置。下一趟冒泡的过程，前一趟已经确定的最小元素不参与比较，待排序序列中就减少了一个元素。每一次冒泡都将待排序序列中的最小元素放到了最终位置。<br>以下是java实现的冒泡排序算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,len=arr.length;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=len-<span class="number">1</span>;j&gt;i;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j-<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j-<span class="number">1</span>];</span><br><span class="line">				arr[j-<span class="number">1</span>]=arr[j];</span><br><span class="line">				arr[j]=temp;</span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			print(arr);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法的性能分析：<br>空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)<br>时间效率：最好情况下，待排序序列基本有序，比较次数为n-1,移动次数为0，时间复杂度为O(n),最坏情况下，初始序列为逆序，需要进行n-1趟冒泡，每次冒泡进行n-i次比较，这种情况下时间复杂度为O(n^2)。平均情况下时间复杂度为O(n^2)。<br>稳定性：冒泡排序是一个稳定的排序算法</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是对冒泡排序的一个改进，其基本思想是基于分治策略，在待排序序列中任取一个元素p作为基准元素，通过一次排序将待排序表氛围独立的两个部分，arr[0…k-1]和arr[k+1…n-1],其中前者中的元素均小于p,后者中的元素均大于p，p则放在其最终位置arr[k]中，这个过程为一次快速排序。然后对两个子序列分别递归的进行快速排序，直至每个部分中只有一个元素或者为空为止。<br>以下是java实现快速排序算法的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">int</span> p = Partition(arr,low,high);</span><br><span class="line">		quickSort(arr,low,p-<span class="number">1</span>);</span><br><span class="line">		quickSort(arr,p+<span class="number">1</span>,high);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  p =arr[low];</span><br><span class="line">	<span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high&amp;&amp;arr[high]&gt;=p) high--;</span><br><span class="line">		arr[low]=arr[high];</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high&amp;&amp;arr[low]&lt;=p) low++;</span><br><span class="line">		arr[high]=arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[low]=p;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速排序算法的关键在于划分操作。划分操作算法也影响着快速排序算法的性能。上面算法中的划分操作主要是假设每次总是以当前表中第一个元素作为枢纽值对表进行划分，表中比枢纽值大的元素向右移动，比枢纽值小的向左移动，从而使得在一次划分操作之后，表中的元素被枢纽值一分为二。<br>快速排序算法的性能分析：<br>空间效率：快速排序算法借助了递归来实现，因此需要一个递归工作栈来保存递归过程中的信息。最好情况下为log(n+1),最坏情况下需要进行n-1次递归调用，因此为最坏情况下为O(n),平均情况下，为O(log(n))。<br>时间效率：快速排序算法的时间效率和划分操作是否对称有关，因此时间效率的关键在于划分算法的实现。最坏情况下即待排序表基本有序或逆序时，此时时间复杂度为O(n^2)。最好情况下，时间复杂度为O(nlog(n))。<br>稳定性：快速排序算法不是一个稳定的排序算法。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想是在每一趟的排序的过程中，在剩下的元素中找出最小的元素放在该趟排序的位置上，例如第i趟排序，则在arr[i+1,n-1]中找出最小的元素放在arr[i]中。经过n-1趟排序就可以完成整个排序过程。</p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>简单选择排序的思想就是以上选择排序的一个实现。<br>以下为java实现的简单选择排序算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> i,j,min;</span><br><span class="line">  	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">  		min=i;</span><br><span class="line">  		<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">  			<span class="keyword">if</span>(arr[j]&lt;arr[min])&#123;</span><br><span class="line">  				min=j;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">if</span>(min!=i)&#123;</span><br><span class="line">  			<span class="keyword">int</span> temp=arr[i];</span><br><span class="line">  			arr[i]=arr[min];</span><br><span class="line">  			arr[min]=temp;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	print(arr);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单选择排序算法性能分析：<br>空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)。<br>时间效率：元素之间的比较次数与初始状态无关，始终是n(n-1)/2,因此时间复杂度为O(n^2)。<br>稳定性：简单选择排序不是一个稳定的排序算法。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种树形选择排序方法，其基本思想就是将待排序序列看成一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲节点与孩子节点之间的关系，在当前无序区中选择最大或者最小的元素。</p>
<p><strong>大顶堆：</strong>在待排序序列中L[1…n]中，如果该序列满足L(i)&gt;=L(2<em>i)且L(i)&gt;=L(2</em>i+1)，则称该种情况组成的堆为大顶堆。<br><strong>小顶堆：</strong>在待排序序列中L[1…n]中，如果该序列满足L(i)&lt;=L(2<em>i)且L(i)&lt;=L(2</em>i+1)，则称该种情况组成的堆为小顶堆。</p>
<p>在大顶堆中，根元素为最大的元素，小顶堆中，根节点是最小元素。</p>
<p>堆排序的基本思想：堆排序的关键在于构建初始堆。n个节点的完全二叉树，最后一个节点是第(n/2)个节点的孩子。对第(n/2)个节点为根的子树按照大顶堆或者小顶堆相应的特点筛选，使该子树成为堆。之后向前依次对第(n/2-1)个节点到第1个节点为根的子树依次筛选。以大顶堆为例，判断该节点值是否大于其左右孩子节点的值，如果不是，则将左右孩子节点中最大的值与该节点进行交换，交换后如果破坏了下一级的堆，则继续按照上述规则构造下一级的堆，直到该节点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根节点。<br>使用堆排序时，首先将L[1…n]中n个元素构建初始堆，大顶堆中，堆顶元素就是最大值。输出堆顶元素后，将堆底元素送入堆顶，此时根节点已不满足大顶堆的性质，此时按照调整规则将以根节点为父节点的子树调整，使其继续保持大顶堆的性质，再输出堆顶元素，重复循环，直到堆中仅剩下一个元素为止。</p>
<p>以下是java实现的堆排序算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">   	buildHeap(arr,len);</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">   		<span class="keyword">int</span> temp=arr[i];</span><br><span class="line">   		arr[i]=arr[<span class="number">0</span>];</span><br><span class="line">   		arr[<span class="number">0</span>]=temp;</span><br><span class="line">   		AdjustDown(arr,<span class="number">0</span>,i);</span><br><span class="line">   	&#125;</span><br><span class="line">   	print(arr);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">   		AdjustDown(arr, i, len);</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> temp = arr[k];</span><br><span class="line">   	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k;i&lt;len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">   		<span class="keyword">if</span>(i&lt;len-<span class="number">1</span>&amp;&amp;arr[i]&lt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">   			i++;</span><br><span class="line">   		&#125;</span><br><span class="line">   		<span class="keyword">if</span>(temp&gt;=arr[i]) <span class="keyword">break</span>;</span><br><span class="line">   		<span class="keyword">else</span>&#123;</span><br><span class="line">   			arr[k]=arr[i];</span><br><span class="line">   			k=i;</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   	arr[k]=temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>堆排序算法的性能分析如下：<br>空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)。<br>时间效率：建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h),h为子树的高度。因此在最好、最坏以及平均情况下，堆排序的时间复杂度为O(nlogn)。<br>稳定性：堆排序算法是一种不稳定的排序算法。</p>
<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序的基本思想：将两个或两个以上的有序表组合成一个新的有序表。如果待排序表中有n个记录，则可以看成是n个有序的子表，每个字表的长度为1，然后两两归并，得到n/2个长度为2或1的有序表，之后再进行两两归并，直到合并成一个长度为n的有序表为止。这称之为2-路归并排序。<br>以下是java实现的归并排序算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> i,j,k;</span><br><span class="line">  	<span class="keyword">for</span>(k=low;k&lt;=high;k++)&#123;</span><br><span class="line">  		temp[k]=arr[k];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++ )&#123;</span><br><span class="line">  		<span class="keyword">if</span>(temp[i]&lt;=temp[j])&#123;</span><br><span class="line">  			arr[k]=temp[i++];</span><br><span class="line">  		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  			arr[k]=temp[j++];</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">while</span>(i&lt;=mid) arr[k++]=temp[i++];</span><br><span class="line">  	<span class="keyword">while</span>(j&lt;=high) arr[k++]=temp[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">  		<span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">  		mergeSort(arr,low,mid);</span><br><span class="line">  		mergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">  		merge(arr,low,mid,high);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>2-路归并排序算法的性能分析如下：<br>空间效率：因为使用了n个单位的辅助空间，因此归并排序的空间复杂度为O(n)。<br>时间效率：每一趟归并的时间复杂度为O(n),需要进行(logN)次归并，因此算法的时间复杂度为O(nlogn)。<br>稳定性：2-路归并排序算法是一个稳定的排序算法。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序不是一种基于比较和交换的排序算法，而是采用多关键字排序思想，借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序分为最高位优先排序和最低位优先排序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述部分给出了各种排序算法的基本思想及其实现。下表为各种排序算法的性质：<br><img src="http://oe7c74ud3.bkt.clouddn.com/compare.png" alt></p>
</div><div class="tags"><a href="/tags/排序/">排序</a><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/2016/12/20/hexo-github-gh-pages搭建静态博客/" class="pre">hexo+github gh-pages搭建静态博客</a><a href="/2016/07/19/关于javascript中prototype对象的理解/" class="next">初识javascript的prototype对象</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">李茶德的日记.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 京ICP备17057625号.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>