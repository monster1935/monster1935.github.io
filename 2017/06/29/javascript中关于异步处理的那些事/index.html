<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录学习、工作、生活"><title>JS中的异步处理 | 李茶德的日记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/styles/stackoverflow-dark.min.css"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS中的异步处理</h1><a id="logo" href="/.">李茶德的日记</a><p class="description">记录学习、工作、生活</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa null"> 首页</i></a><a href="/archives/"><i class="fa null"> 归档</i></a><a href="/about/"><i class="fa null"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS中的异步处理</h1><div class="post-meta">2017-06-29<span> | </span><span class="category"><a href="/categories/前端/">前端</a></span></div><div class="post-content"><p>记得2015年看一些node的代码时，示例中往往会使用回调函数做一些异步处理，去年的时候看会发现大部分成了promise，当今年再看时发现大部分已经成了async/await。为什么js的异步操作解决方案更新的如此之快，每种方案的使用场景以及弊端是什么，下文中给出了介绍。以下均为自己的一些理解，描述如有偏差欢迎指正。</p>
<a id="more"></a>
<h3 id="JS中异步和同步的概念"><a href="#JS中异步和同步的概念" class="headerlink" title="JS中异步和同步的概念"></a>JS中异步和同步的概念</h3><h4 id="什么是同步呢？"><a href="#什么是同步呢？" class="headerlink" title="什么是同步呢？"></a>什么是同步呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi, javascript.'</span>);<br>&#125;<br>print(); <span class="hljs-comment">// hi,javascript.</span><br></code></pre></td></tr></table></figure>
<p>如上述代码所示，调用该函数后不通过任何其他手段就能得到该代码运行的结果。</p>
<h4 id="什么是异步呢？"><a href="#什么是异步呢？" class="headerlink" title="什么是异步呢？"></a>什么是异步呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br>fs.readFile(<span class="hljs-string">'./image.png'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, buffer</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  process(buffer);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>如上述代码所示，调用readFile后并不能立即获得代码运行的结果，需要通过一定手段才能间接获取到代码运行的结果。上述代码中采用了 <code>回调函数</code> 机制获取到了代码运行后的结果，并进行接下来的操作。</p>
<p>综上，个人理解，如果函数运行后如果无法<strong>直接</strong>获取到程序运行的结果，还需要其他手段辅助才能获取到程序运行结果的便可以称之为异步。否则便是该函数则是一个同步的过程。</p>
<h3 id="JS-中的异步编程"><a href="#JS-中的异步编程" class="headerlink" title="JS 中的异步编程"></a>JS 中的异步编程</h3><h4 id="为什么需要异步呢？"><a href="#为什么需要异步呢？" class="headerlink" title="为什么需要异步呢？"></a>为什么需要异步呢？</h4><p>JS 的执行环境为单线程，在单线程的执行环境下通过异步编程的方式可以提高程序执行的效率，避免同步方式带来的等待问题。</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">阮老的教程</a>中总结到了在js中异步编程的几种方式，这篇文章的时间是2012年，目前前端新技术的涌现使得在js中处理异步的过程已经远远不止这几种方式。下面从 回调函数、promise、generator+co、async/await 四种方式下对异步的处理来解释js下的异步编程处理。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>上述对于异步的阐述中示例代码给出了回调函数的一个示例，通过传入一个回调函数获取到程序运行的结果。</p>
<p>什么是回调函数呢？</p>
<blockquote>
<p>In computer programming, a callback is a reference to a piece of executable code that is passed as an argument to other code. 来自维基百科的定义</p>
</blockquote>
<p>在js中回调函数指的是将待执行的函数A作为参数传递到另一个函数B中，在函数B中执行函数A。A称之为回调函数，如果传入的是一个函数表达式（没有函数名称），称之为匿名回调函数。</p>
<p>segmentfault上看到一个很经典的关于回调的比喻：</p>
<blockquote>
<p>你有事去隔壁寝室找同学，发现人不在，你怎么办呢？<br>方法1，每隔几分钟再去趟隔壁寝室，看人在不<br>方法2，拜托与他同寝室的人，看到他回来时叫一下你<br>前者是轮询，后者是回调。<br>那你说，我直接在隔壁寝室等到同学回来可以吗？<br>可以啊，只不过这样原本你可以省下时间做其他事，现在必须浪费在等待上了。把原来的非阻塞的异步调用变成了阻塞的同步调用。<br>JavaScript的回调是在异步调用场景下使用的，使用回调性能好于轮询。</p>
</blockquote>
<p>回调函数实践中的回调地狱问题（callback hell ）:</p>
<p>如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 此处的try/catch 无法捕获内部回调函数的错误信息</span><br>  connection.query(sql, (err, result) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-comment">// 此处如果抛出错误的话，无法被外层的try/catch捕获</span><br>          <span class="hljs-built_in">console</span>.err(err)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          connection.query(sql, (err, result) =&gt; &#123;<br>              <span class="hljs-keyword">if</span>(err) &#123;<br>                  <span class="hljs-built_in">console</span>.err(err)<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  ...<br>              &#125;<br>          &#125;)<br>      &#125;<br>  &#125;)<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述代码当回调函数层级过多时会出现回调地狱问题，其主要弊端有：</p>
<ul>
<li>代码可读性差，不利于后期的修改维护</li>
<li>外部无法捕获回调函数内部抛出的错误（鉴于此可能会导致回调函数被执行多次）</li>
</ul>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><blockquote>
<p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
</blockquote>
<p>上述是ECMA对Promise的定义。其内部定义并保存了一个异步操作的结果，该结果在Promise对象创建时是未知的。通过对Promise对象代理的异步过程的执行结果的成功和失败绑定对应的处理方法，我们可以按照同步的方式书写异步代码。</p>
<p>Promise的内部保存有三种状态：</p>
<ul>
<li>pending 状态：代表初始状态</li>
<li>fulfilled 状态：代表操作已经成功完成</li>
<li>rejected 状态：代表操作失败</li>
</ul>
<p>Promise通过级联式的api调用代替了回调函数的层层嵌套，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      resolve(<span class="hljs-string">'1'</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br>a.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(val)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>Promise的错误处理机制，可以避免回调函数在嵌套中无法被外部错误机制捕获的问题。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-number">1</span> ? resolve() : reject()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'resolve'</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'reject'</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>最后的catch会捕获整个promise链中抛出的错误。具体Promise的用法可见阮老师的<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 对象</a>一节。</p>
<p>Promise 较之回调函数有以下好处：</p>
<ul>
<li>代码结构清晰</li>
<li>可以捕获流程内部抛出的错误信息</li>
</ul>
<h4 id="Generator-co"><a href="#Generator-co" class="headerlink" title="Generator+co"></a>Generator+co</h4><p>ES2015中出现了Generator语法，随着Generator的出现，这一异步编程解决方案可以让我们更近乎同步的方式写代码，在代码结构上相对promise更友好。</p>
<p>什么是Generator？</p>
<p>阮大是这样说的： Generator是一个状态机，其内部封装了多个状态，在执行Generator函数时，会返回一个遍历器对象，通过改对象，依次遍历Generator函数内部的每一个状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">asyncJob</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...其他代码</span><br>  <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">yield</span> readFile(fileA);<br>  <span class="hljs-comment">// ...其他代码</span><br>&#125;<br><span class="hljs-keyword">var</span> g = asyncJob();<br>g.next();<br></code></pre></td></tr></table></figure>
<p>如上述所示，代码中给出了使用Generator函数的示例。其中，Generator的function与函数名之间有一个*，函数内部使用yield关键词，定义不同的状态。</p>
<p>Generator函数中封装了不同的状态，通过next的调用可以依次遍历到所有的状态，如何自动管理generator的流程。业内较为出名是TJ大神的co模块，co模块用于Generator函数的自动执行。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      resolve(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">var</span> b = co(<span class="hljs-function"><span class="hljs-keyword">function</span> *(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">yield</span> a();<br>    <span class="hljs-built_in">console</span>.log(val)<br>&#125;)<br><br>b()<br></code></pre></td></tr></table></figure>
<p>co模块的具体原理详见：<a href="http://es6.ruanyifeng.com/#docs/generator-async#co-模块" target="_blank" rel="noopener">co模块</a></p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>ES2016草案中出现了async/await异步处理方案，其在语言层面解决JavaScript的异步回调问题。其使用方式和generator+co 的方式很像，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      resolve(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">await</span> a()<br>  <span class="hljs-built_in">console</span>.log(val)<br>&#125;<br><br>b()<br></code></pre></td></tr></table></figure>
<p>async/await机制有着以下特点：</p>
<ul>
<li>语言层面的异步处理解决方案</li>
<li>基于promise实现，不能用于普通的回调函数</li>
</ul>
<p>使用async/await 有着以下不同：</p>
<ul>
<li>函数前面多了一个async关键字，相比于generator函数前面加的是一个*</li>
<li>await只能用在async函数中，用在普通函数中会报错</li>
<li>相比于generator，自带生成器，可以直接自动运行</li>
</ul>
<p>关于async/await的优点，可以看<a href="http://kiwenlau.com/2017/04/01/nodejs-async-await/" target="_blank" rel="noopener">Async/Await替代Promise的6个理由</a>这篇文章，这篇文章详细列述了使用async/await的几大优点。</p>
<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">Javascript异步编程的4种方法</a></p>
<p><a href="https://segmentfault.com/q/1010000000140970" target="_blank" rel="noopener">JavaScript 回调函数怎么理解</a></p>
<p><a href="https://github.com/rccoder/blog/issues/17" target="_blank" rel="noopener">回调地狱的今生前世</a></p>
<p><a href="https://juejin.im/entry/58dc7031ac502e006cef6f2c" target="_blank" rel="noopener">深刻理解 ES 6 中的 Promise</a></p>
</div><div class="tags"><a href="/tags/javascript/">javascript</a><a href="/tags/异步/">异步</a></div><div class="post-nav"><a href="/2017/07/26/Vue2.4新增属性解析/" class="pre">Vue2.4版本中新添加的$attrs以及$listeners属性使用</a><a href="/2017/06/29/js单例模式的问题/" class="next">JS单例模式的一种应用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><span>分类</span></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">34</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客搭建/">博客搭建</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/客户端/">客户端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><span>最近文章</span></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/12/与自己和解/">与自己和解</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/25/读未来简史/">读未来简史</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/10/读心：稻盛和夫一生的嘱托/">读心：稻盛和夫一生的嘱托</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/LeetCode-189-旋转数组/">LeetCode-189-旋转数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/LeetCode-122-买卖股票的最佳时机 II/">LeetCode-122-买卖股票的最佳时机 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/LeetCode-26-删除数组中的重复元素/">LeetCode-26-删除数组中的重复元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/15/我是如何看待工作的/">我是如何看待工作的</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/与青春有关的日子/">观《与青春有关的日子》</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/redux-middleware/">Redux 中间件机制探底</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/redux-and-react-redux/">状态管理之 Redux & React Redux</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">李茶德的日记.</a><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn"> 京ICP备17057625号.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>